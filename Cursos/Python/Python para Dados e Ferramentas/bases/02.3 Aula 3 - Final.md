# üß† Aula 03 ‚Äî A Chave M√°gica: Importando Dados com Pandas

## üéì Ol√°, Aventureiro dos Dados\!

At√© agora, voc√™ aprendeu a criar DataFrames e Series manualmente. Isso foi essencial para entender a estrutura interna do Pandas. Mas no mundo real, a m√°gica come√ßa quando voc√™ precisa trabalhar com dados que j√° existem, guardados em arquivos.

Esta aula √© o seu primeiro passo nesse mundo. Vamos aprender a usar o Pandas para "abrir" esses arquivos e transform√°-los em DataFrames prontos para a a√ß√£o. O `read_csv()` e o `read_excel()` ser√£o suas novas ferramentas favoritas.

  - **Tema Central**: Leitura de arquivos externos com Pandas
  - **Comando(s) Essencial(is)**: `pd.read_csv()`, `pd.read_excel()`, e seus principais par√¢metros (`sep`, `encoding`, `usecols`, `skiprows`, `nrows`)

-----

# üìç Do Arquivo ao DataFrame: Uma Tradu√ß√£o Necess√°ria

Pense em um arquivo CSV (Comma-Separated Values) ou Excel. Eles s√£o apenas peda√ßos de texto ou de dados bin√°rios. Para o Pandas, eles s√£o como livros em uma l√≠ngua estrangeira.

A fun√ß√£o `read_csv()` e `read_excel()` s√£o os tradutores. Elas leem o conte√∫do do arquivo e o convertem em uma tabela, um **DataFrame**, que o Python consegue entender e manipular. O sucesso dessa "tradu√ß√£o" depende de voc√™ fornecer as "instru√ß√µes" corretas. √â por isso que os par√¢metros s√£o t√£o importantes.

**Por que focar nos par√¢metros?** Porque √© aqui que a maioria dos erros acontece. Um separador incorreto pode transformar sua tabela em uma √∫nica coluna bagun√ßada. Uma codifica√ß√£o errada pode gerar caracteres estranhos. Aprender a ajustar esses par√¢metros √© a diferen√ßa entre uma importa√ß√£o bem-sucedida e horas de frustra√ß√£o.

-----

# üìö Conte√∫do Explicado: As Ferramentas de Importa√ß√£o

### 1\. `read_csv()`: O Leitor Universal de Dados Tabulares

O arquivo CSV √© o formato mais comum para compartilhar dados tabulares. Ele √© basicamente um arquivo de texto onde os valores s√£o separados por um caractere, geralmente uma v√≠rgula (por isso "CSV"). A fun√ß√£o `read_csv()` √© otimizada para ler esse formato de forma eficiente.

```python
pd.read_csv(filepath_or_buffer, sep=',', encoding=None, usecols=None, skiprows=None, nrows=None)
```

  - **`filepath_or_buffer`**: O endere√ßo do seu arquivo. Pode ser o nome do arquivo na mesma pasta (ex: `'dados.csv'`) ou o caminho completo (ex: `'C:/Users/seu_usuario/Desktop/dados.csv'`).
  - **`sep`**: O separador de campos. A maioria dos arquivos usa v√≠rgulas (`,`), mas em muitos pa√≠ses, como o Brasil, √© comum usar o ponto e v√≠rgula (`;`). Outros podem usar tabula√ß√£o (`\t`).
  - **`encoding`**: A codifica√ß√£o de caracteres. √â a "chave de tradu√ß√£o" do nosso arquivo. O padr√£o `utf-8` funciona bem para a maioria dos casos. Mas se voc√™ encontrar caracteres estranhos (como `√É¬ß` em vez de `√ß`), o culpado provavelmente √© a codifica√ß√£o. Tente `latin1` ou `iso-8859-1`.
  - **`usecols`**: Uma lista com os nomes das colunas que voc√™ realmente precisa. Essa √© uma dica de ouro para otimizar a leitura, pois o Pandas ignorar√° o resto, economizando mem√≥ria e tempo.
  - **`skiprows`**: Se o seu arquivo tem linhas de cabe√ßalho ou metadados in√∫teis no in√≠cio, este par√¢metro permite que voc√™ as ignore.
  - **`nrows`**: Quantas linhas voc√™ quer ler. Perfeito para arquivos gigantes, onde voc√™ s√≥ precisa de uma amostra para inspecionar os dados antes de carregar tudo.

-----

### 2\. `read_excel()`: Lidando com Planilhas Mais Complexas

Arquivos Excel (`.xlsx`) s√£o mais complexos que CSVs porque podem ter m√∫ltiplas abas, f√≥rmulas e formata√ß√µes. O `read_excel()` lida com essa complexidade, mas √© menos eficiente que o `read_csv()` para arquivos muito grandes.

```python
pd.read_excel(io, sheet_name=0, usecols=None, skiprows=None, nrows=None)
```

  - **`io`**: O caminho para o seu arquivo `.xlsx`.
  - **`sheet_name`**: O Pandas pode ler abas espec√≠ficas. Voc√™ pode usar o nome da aba (ex: `'Janeiro'`) ou o √≠ndice (ex: `0` para a primeira aba, `1` para a segunda, e assim por diante).

Os outros par√¢metros (`usecols`, `skiprows`, `nrows`) funcionam de forma semelhante aos do `read_csv()`, tornando o aprendizado consistente.

-----

## üìà Exemplos Pr√°ticos: M√£o na Massa

Vamos ver como usar esses comandos na pr√°tica, simulando situa√ß√µes reais que voc√™ encontrar√°.

### a) O Caso Cl√°ssico: Lendo um CSV Simples

Seu arquivo `vendas.csv` est√° no formato padr√£o. Apenas um comando basta.

```python
import pandas as pd

# O Pandas assume que o separador √© ',' e a codifica√ß√£o √© 'utf-8'
df = pd.read_csv('vendas.csv')
print(df.head())
```

### b) O Desafio Comum: CSV com Separador e Codifica√ß√£o Diferentes

Voc√™ baixou um arquivo `clientes.csv` de um sistema legado. Ele usa ponto e v√≠rgula e tem caracteres acentuados.

```python
df = pd.read_csv('clientes.csv', sep=';', encoding='latin1')
```

**Percebeu a diferen√ßa?** Apenas dois par√¢metros extras resolvem o problema e permitem que o Pandas "entenda" o arquivo corretamente.

### c) Economizando Tempo e Mem√≥ria

Um arquivo `produtos.csv` tem 20 colunas, mas voc√™ s√≥ precisa de duas.

```python
df = pd.read_csv('produtos.csv', usecols=['nome', 'preco'])
```

Isso √© crucial para performance, especialmente com grandes volumes de dados.

### d) Lendo um Relat√≥rio Excel

Voc√™ recebeu um relat√≥rio em Excel com uma aba de `Janeiro` e outra de `Fevereiro`.

```python
# Lendo a aba de Janeiro
df_janeiro = pd.read_excel('relatorio.xlsx', sheet_name='Janeiro')

# Lendo a aba de Fevereiro
df_fevereiro = pd.read_excel('relatorio.xlsx', sheet_name='Fevereiro')
```

-----

## üß™ Demonstra√ß√£o Aplicada: Resolvendo um Problema Real

Imagine que voc√™ recebeu um arquivo chamado `vendas_loja.csv`. Ele parece estranho quando voc√™ o abre no editor de texto, mas voc√™ sabe que ele tem separador `;` e a codifica√ß√£o de caracteres √© `latin1` devido √† presen√ßa de acentua√ß√µes. Al√©m disso, voc√™ s√≥ precisa das colunas `dia`, `valor` e `loja`.

```python
import pandas as pd

try:
    df = pd.read_csv(
        'vendas_loja.csv',
        sep=';',
        encoding='latin1',
        usecols=['dia', 'valor', 'loja']
    )

    print("--- Dados importados com sucesso! ---")
    
    # Ap√≥s a leitura, o pr√≥ximo passo √© sempre a inspe√ß√£o.
    print(df.head())
    print("\n")
    print(df.info())

except FileNotFoundError:
    print("Erro: O arquivo 'vendas_loja.csv' n√£o foi encontrado. Verifique o caminho.")
except Exception as e:
    print(f"Ocorreu um erro durante a leitura do arquivo: {e}")
```

**O que fizemos aqui?**

  - Usamos um bloco `try-except` para lidar com poss√≠veis erros, como o arquivo n√£o existir.
  - Passamos todos os par√¢metros necess√°rios para a fun√ß√£o `read_csv()`.
  - Ap√≥s a leitura, usamos `.head()` e `.info()` para inspecionar os dados. Isso nos garante que a importa√ß√£o funcionou e que os tipos de dados foram lidos corretamente. **Esta √© uma pr√°tica indispens√°vel\!**

-----

## üìé Dicas e Armadilhas: O que o Profissional Faz

  - **Erros de `encoding`**: S√£o os mais comuns. Se sua primeira tentativa falhar, o pr√≥ximo passo √© tentar `encoding='latin1'`.
  - **`sep` Incorreto**: Se o seu DataFrame for lido com uma √∫nica coluna, o problema √© quase sempre o separador. Abra o arquivo em um editor de texto simples para verificar qual √© o separador.
  - **`usecols` √© seu amigo**: Para arquivos grandes, limitar as colunas pode acelerar a leitura e reduzir o uso de mem√≥ria em 50%, 80% ou at√© mais.
  - **Inspecione, Inspecione, Inspecione**: A leitura √© apenas o come√ßo. Sempre verifique as primeiras linhas (`.head()`) e os tipos de dados (`.info()`). Isso revela problemas que podem ter passado despercebidos, como uma coluna num√©rica sendo lida como texto.

-----

## üîÑ Transi√ß√µes e Conex√µes

  - **Vem de**: A aula anterior, onde criamos DataFrames manualmente. Agora, em vez de `pd.DataFrame()`, usaremos `pd.read_csv()` ou `pd.read_excel()` para obter nossos dados.
  - **Vai para**: A pr√≥xima aula, onde mergulharemos na **Explora√ß√£o de Dados**. A partir de agora, voc√™ ter√° DataFrames reais para trabalhar\! Aprenderemos a extrair informa√ß√µes, fazer filtros e resumir os dados para entender o que eles nos contam.

-----

## üé® Recursos Visuais e Mentais (Para Pensar)

1.  **A Pir√¢mide da An√°lise de Dados**: Pense na importa√ß√£o como a base s√≥lida da pir√¢mide. Se a base n√£o for bem feita, a pir√¢mide inteira (limpeza, explora√ß√£o, visualiza√ß√£o) desmorona.
2.  **O Fluxo de Trabalho (Agora Completo)**: Importar ‚Üí Inspecionar ‚Üí Limpar ‚Üí Analisar ‚Üí Visualizar.
3.  **A Leitura como um Ritual**: A leitura de um arquivo n√£o √© um comando √∫nico. √â um processo que envolve tentativa e erro, ajuste de par√¢metros e, mais importante, a inspe√ß√£o do resultado.

-----

Voc√™ acabou de dar o passo mais importante: conectar-se com dados do mundo real. Agora que voc√™ sabe como import√°-los, o universo da an√°lise de dados est√° √† sua espera.

Pronto para come√ßar a fazer as perguntas certas aos seus dados?

---

# üß™ Exerc√≠cios

## üß© Parte 1: Importa√ß√£o B√°sica

1. **Leia o arquivo `dados.csv` usando o comando `pd.read_csv()` e exiba as 5 primeiras linhas com `.head()`.**

2. **Leia o arquivo `clientes.csv`, que usa o separador `;`, e exiba as 5 primeiras linhas.**

3. **Leia o arquivo `produtos.csv`, que est√° codificado em `latin1`, e exiba as informa√ß√µes gerais do DataFrame com `.info()`.**

4. **Leia o arquivo `vendas.csv`, mas carregue apenas as colunas `'produto'` e `'valor'`.**

5. **Leia o arquivo `relatorio.csv`, ignorando as 3 primeiras linhas, e exiba as 5 primeiras linhas.**

---

## üîç Parte 2: Trabalhando com Arquivos Excel

6. **Leia o arquivo `planilha.xlsx` e carregue a aba chamada `'Janeiro'`.**

7. **Leia o arquivo `planilha.xlsx` e carregue a segunda aba (√≠ndice 1).**

8. **Leia o arquivo `planilha.xlsx`, mas carregue apenas as colunas `'nome'` e `'idade'`.**

9. **Leia o arquivo `planilha.xlsx`, ignorando as 2 primeiras linhas da aba `'Fevereiro'`.**

10. **Leia o arquivo `planilha.xlsx`, carregando apenas as 10 primeiras linhas da aba `'Mar√ßo'`.**

---

## üß± Parte 3: Ajustes e Tratamento Durante a Importa√ß√£o

11. **Leia o arquivo `dados.csv`, mas substitua os valores ausentes (`NaN`) por `0` durante a importa√ß√£o.**

12. **Leia o arquivo `clientes.csv`, mas renomeie as colunas `'nome'` para `'cliente'` e `'idade'` para `'anos'` durante a importa√ß√£o.**

13. **Leia o arquivo `produtos.csv`, mas converta a coluna `'preco'` para o tipo `float` durante a importa√ß√£o.**

14. **Leia o arquivo `vendas.csv`, mas defina a coluna `'data'` como √≠ndice do DataFrame.**

15. **Leia o arquivo `relatorio.csv`, mas carregue apenas as linhas onde a coluna `'status'` √© igual a `'ativo'`.**

---

## üßº Parte 4: Lidando com Erros e Arquivos Grandes

16. **Tente ler o arquivo `inexistente.csv` e trate o erro de `FileNotFoundError` com uma mensagem personalizada.**

17. **Leia o arquivo `grande.csv`, mas carregue apenas as primeiras 1000 linhas para economizar mem√≥ria.**

18. **Leia o arquivo `dados_corrompidos.csv`, ignorando as linhas que cont√™m erros.**

19. **Leia o arquivo `clientes.csv`, mas exiba uma mensagem de erro personalizada se o arquivo n√£o estiver no formato esperado.**

20. **Leia o arquivo `vendas.csv`, mas carregue apenas as colunas `'produto'` e `'valor'`, e trate os valores ausentes na coluna `'valor'` substituindo-os pela m√©dia da coluna.**

---