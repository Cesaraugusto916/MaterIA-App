# 🧠 Aula 06 — O Superfiltro: Encontrando Informações com Máscaras

## 🎓 Olá, Aventureiro\!

Na última aula, você se tornou um mestre em usar a bússola (`.loc[]` e `.iloc[]`) para encontrar qualquer ponto em seu mapa de dados. Mas e se a pergunta for diferente? Em vez de "O que está no ponto (X, Y)?", e se a pergunta for "Quais são todos os pontos com a característica Z?".

Esta aula vai te dar esse poder. Vamos aprender a usar **filtros lógicos** para selecionar linhas de um DataFrame que atendam a critérios específicos. É como usar um filtro em uma planilha, mas com a superpotência e precisão do Python.

  - **Tema Central**: Condições e máscaras para filtrar dados
  - **Comando(s) Essencial(is)**: `df[condição]`, `df.loc[condição]`, operadores lógicos (`&`, `|`, `~`), `.isin()`, `.between()`

-----

# 📍 A Magia da Máscara Booleana: Sim ou Não?

No coração da filtragem com Pandas está o conceito de **máscara booleana**. Pense nela como uma lista de `True` e `False` com o mesmo número de linhas do seu DataFrame. O `True` diz "mantenha esta linha" e o `False` diz "ignore esta linha".

Quando você escreve uma condição, como `df['vendas'] > 300`, o Pandas não te dá um único resultado. Ele te dá essa máscara booleana:

```
0    False
1    False
2    False
3     True
4     True
Name: vendas, dtype: bool
```

Depois, você passa essa máscara para o DataFrame, e ele magicamente retorna apenas as linhas que correspondem ao valor `True`. Entender isso é a chave para dominar a filtragem.

-----

# 📚 Conteúdo Explicado: As Ferramentas de Filtragem

### 1\. A Filtragem Simples e Direta

A sintaxe mais comum e direta para filtrar é aninhar a condição dentro dos colchetes do DataFrame.

```python
# A condição `df['coluna'] > valor` gera a máscara booleana.
# O DataFrame `df` usa essa máscara para retornar as linhas desejadas.
df[df['coluna'] > valor]
```

### 2\. A Filtragem com `loc[]`: Combinando Poderes

Você já é um mestre em `loc[]`. Agora, vamos combiná-lo com a filtragem\! Em vez de passar um rótulo, você passa a sua máscara booleana. Isso te dá a flexibilidade de filtrar as linhas e, ao mesmo tempo, selecionar colunas específicas.

```python
# Passamos a máscara booleana como o seletor de linhas
df.loc[df['coluna'] == 'valor', ['coluna_a', 'coluna_b']]
```

### 3\. Conectando as Ideias: Operadores Lógicos

A vida raramente se resume a uma única condição. E se você quiser encontrar as vendas que sejam "maiores que R$ 300 **E** da loja 'A'"? É aqui que os operadores lógicos entram em cena.

  - `&` (E): Ambas as condições devem ser verdadeiras.
  - `|` (OU): Pelo menos uma das condições deve ser verdadeira.
  - `~` (NÃO): Inverte a condição.
  - **Atenção\!** Quando você combina condições, é **obrigatório** envolvê-las em parênteses. `(condição_1) & (condição_2)`.

-----

### 4\. Atalhos Poderosos: `isin()` e `between()`

O Pandas oferece métodos especiais que tornam a escrita de filtros complexos muito mais fácil e legível.

  - **`.isin()`**: Perfeito para verificar se um valor está em uma lista de opções. É muito mais limpo do que escrever `(coluna == 'valor1') | (coluna == 'valor2')`.

    ```python
    # Filtra por produtos que são 'A' OU 'B'
    df[df['categoria'].isin(['A', 'B'])]
    ```

  - **`.between()`**: Ideal para filtrar valores que estão dentro de um intervalo, como `maior ou igual a X` e `menor ou igual a Y`.

    ```python
    # Filtra preços entre 10 e 50 (incluindo 10 e 50)
    df[df['preco'].between(10, 50)]
    ```

-----

## 📈 Exemplos Práticos: Mão na Massa

Vamos usar um DataFrame simples para praticar a filtragem.

```python
import pandas as pd

df = pd.DataFrame({
    'produto': ['A', 'B', 'C', 'D'],
    'preco': [10, 25, 50, 80],
    'estoque': [100, 0, 200, 50]
})

print("--- DataFrame original ---")
print(df)
print("\n")

# Produtos com preço acima de R$ 30
print("--- Produtos com preço > 30 ---")
print(df[df['preco'] > 30])
print("\n")

# Produtos fora de estoque (igual a 0)
print("--- Produtos sem estoque ---")
print(df[df['estoque'] == 0])
print("\n")

# Produtos com preço entre R$ 20 e R$ 60 (inclusive)
print("--- Produtos com preço entre 20 e 60 ---")
print(df[df['preco'].between(20, 60)])
```

**Percebeu a lógica?** Cada condição que passamos para `df[...]` retorna um novo DataFrame, que é o subconjunto desejado.

-----

## 🧪 Demonstração Aplicada: Resolvendo um Problema Real

Imagine que você precisa analisar as vendas acima de R$ 300, mas somente da loja 'A'. É um problema de múltiplas condições, perfeito para o que acabamos de aprender.

```python
df = pd.DataFrame({
    'dia': ['seg', 'ter', 'qua', 'qui', 'sex'],
    'vendas': [250, 300, 280, 410, 380],
    'loja': ['A', 'A', 'B', 'B', 'A']
})

# Vamos criar a máscara booleana em uma variável para maior clareza
print("--- Máscara booleana ---")
filtro = (df['vendas'] > 300) & (df['loja'] == 'A')
print(filtro)
print("\n")

# Agora aplicamos o filtro para obter o DataFrame
print("--- Resultado filtrado ---")
df_filtrado = df[filtro]
print(df_filtrado)
```

**O que fizemos aqui?**
Primeiro, construímos nossa "máscara" com as duas condições. A primeira parte `(df['vendas'] > 300)` nos diz quais vendas são altas, e a segunda `(df['loja'] == 'A')` nos diz quais são da loja A. O operador `&` (E) garante que apenas as linhas que satisfazem **ambas** as condições sejam marcadas como `True`. Por fim, passamos a máscara para o DataFrame e obtivemos o resultado exato que queríamos.

-----

## 📎 Dicas e Armadilhas: O que o Profissional Faz

  - **Parênteses, sempre\!**: A prioridade de operadores em Python pode gerar erros inesperados se você esquecer os parênteses em condições compostas. `(condição_1) & (condição_2)` é a única forma segura de escrever.
  - **`NaN` e `==`**: A comparação `df['coluna'] == np.nan` **nunca** retorna `True`. Para valores ausentes, use sempre `df['coluna'].isna()`.
  - **Case-sensitive**: O `.isin()` e o operador `==` são sensíveis a maiúsculas e minúsculas. `'a'` é diferente de `'A'`.

-----

## 🔄 Transições e Conexões

  - **Vem de**: A aula anterior, onde você aprendeu a selecionar dados por rótulo e posição. A filtragem é um passo além: em vez de selecionar pela "localização" (`.loc[]`), você seleciona pelo "conteúdo" (`df[...]`).
  - **Vai para**: A próxima aula, que irá complementar a filtragem. Com o DataFrame já filtrado, aprenderemos a **ordená-lo e agrupá-lo** para resumir e visualizar as informações de forma ainda mais poderosa.

-----

## 🎨 Recursos Visuais e Mentais (Para Pensar)

1.  **A Máscara como um "Filtrador"**: Pense na máscara booleana como um filtro de café: você passa todos os dados, mas só o que atende à condição (o café passado) continua para o próximo passo.
2.  **O Fluxo de Trabalho (Com a Filtragem)**: Importar → Explorar → Selecionar → **Filtrar (esta aula)** → Analisar → Visualizar.
3.  **Filtragem = Respostas**: A filtragem é o primeiro passo para obter respostas valiosas dos seus dados. Cada filtro é uma pergunta que você faz ao seu DataFrame.

-----

Você acabou de ganhar um dos poderes mais importantes do Pandas. A filtragem vai ser sua aliada em praticamente todas as suas análises.

Pronto para organizar e resumir seus dados filtrados?

---

# 🧪 Exercícios

## 🧩 Parte 1: Filtragem Simples

1. **Leia o arquivo `dados.csv` e filtre as linhas onde a coluna `'idade'` seja maior que 30.**

2. **Filtre as linhas do DataFrame `clientes.csv` onde a coluna `'cidade'` seja igual a `'São Paulo'`.**

3. **Leia o arquivo `produtos.csv` e filtre os produtos com preço maior que 50.**

4. **Filtre as linhas do DataFrame `vendas.csv` onde a coluna `'vendas'` seja menor ou igual a 300.**

5. **Leia o arquivo `relatorio.csv` e filtre as linhas onde a coluna `'status'` seja `'ativo'`.**

---

## 🔍 Parte 2: Filtragem com Operadores Lógicos

6. **Filtre as linhas do DataFrame `dados.csv` onde a coluna `'idade'` seja maior que 30 e a coluna `'cidade'` seja `'Rio de Janeiro'`.**

7. **Filtre as linhas do DataFrame `clientes.csv` onde a coluna `'estado'` seja `'SP'` ou `'RJ'`.**

8. **Leia o arquivo `produtos.csv` e filtre os produtos com preço maior que 20 e estoque menor que 100.**

9. **Filtre as linhas do DataFrame `vendas.csv` onde a coluna `'vendas'` seja maior que 300 ou a coluna `'loja'` seja `'B'`.**

10. **Leia o arquivo `relatorio.csv` e filtre as linhas onde a coluna `'status'` não seja `'ativo'`.**

---

## 🧱 Parte 3: Métodos `.isin()` e `.between()`

11. **Filtre as linhas do DataFrame `dados.csv` onde a coluna `'cidade'` esteja entre as opções `'São Paulo'` e `'Rio de Janeiro'` usando `.isin()`.**

12. **Leia o arquivo `produtos.csv` e filtre os produtos com preço entre 10 e 50 usando `.between()`.**

13. **Filtre as linhas do DataFrame `vendas.csv` onde a coluna `'vendas'` esteja entre 200 e 400 usando `.between()`.**

14. **Leia o arquivo `clientes.csv` e filtre as linhas onde a coluna `'estado'` esteja entre as opções `'SP'`, `'RJ'` e `'MG'` usando `.isin()`.**

15. **Filtre as linhas do DataFrame `relatorio.csv` onde a coluna `'data'` esteja entre `'2023-01-01'` e `'2023-12-31'` usando `.between()`.**

---

## 🧼 Parte 4: Filtragem Avançada

16. **Leia o arquivo `dados.csv` e filtre as linhas onde a coluna `'idade'` seja maior que 30 e a coluna `'cidade'` não seja `'São Paulo'`.**

17. **Filtre as linhas do DataFrame `clientes.csv` onde a coluna `'estado'` seja `'SP'` e a coluna `'idade'` esteja entre 20 e 40.**

18. **Leia o arquivo `produtos.csv` e filtre os produtos com preço maior que 50 ou estoque igual a 0.**

19. **Filtre as linhas do DataFrame `vendas.csv` onde a coluna `'vendas'` seja maior que 300 e a coluna `'loja'` seja `'A'`.**

20. **Leia o arquivo `relatorio.csv` e filtre as linhas onde a coluna `'status'` seja `'ativo'` e a coluna `'valor'` seja maior que 500.**

---