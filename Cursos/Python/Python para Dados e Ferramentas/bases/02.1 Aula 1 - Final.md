# üß† Aula 01 ‚Äî A Jornada Come√ßa: Dominando a `Series`

## üéì Ol√°, Futuro Cientista de Dados\!

Bem-vindo √† primeira etapa da sua jornada com **Pandas**\! Nesta aula, vamos desvendar os segredos da estrutura de dados mais b√°sica e, ao mesmo tempo, mais poderosa da biblioteca: a **Series**. Pense nela como a c√©lula-tronco do Pandas ‚Äî a partir dela, tudo se desenvolve.

Nosso objetivo aqui √© ir al√©m da sintaxe. Quero que voc√™ entenda o **porqu√™** por tr√°s de cada comando, construindo uma base s√≥lida para manipular dados como um profissional.

  - **Tema Central**: A estrutura de dados **`Series`**
  - **Comando(s) Essencial(is)**: `pd.Series()`, `.head()`, `.tail()`, `.describe()`, `.mean()`, `.sum()`, `.isna()`, `.fillna()`, `.dropna()`, `.rolling()`

-----

# üìç A Series: O Cora√ß√£o Unidimensional do Pandas

Imagine que voc√™ tem uma √∫nica coluna de uma planilha: os valores de vendas di√°rias, a idade de um grupo de pessoas, as notas de um aluno em diferentes disciplinas. Esses dados, por si s√≥, j√° carregam um significado. A **Series** do Pandas √© exatamente isso: uma estrutura de dados de uma dimens√£o, como uma lista, mas com uma superpot√™ncia.

Essa superpot√™ncia √© o seu **√≠ndice** (ou r√≥tulo).

Enquanto uma lista comum do Python usa posi√ß√µes num√©ricas (0, 1, 2...), a Series permite que voc√™ nomeie esses "endere√ßos" de forma significativa, como `'segunda-feira'`, `'nota_do_aluno'`, ou `'vendas_de_mar√ßo'`.

**Por que isso √© t√£o importante?** Porque permite que o Pandas execute opera√ß√µes de forma **inteligente**. Ele n√£o se importa apenas com os valores, mas tamb√©m com os r√≥tulos. Isso evita erros e torna a manipula√ß√£o de dados muito mais intuitiva, como veremos mais adiante. A Series √© a funda√ß√£o para a estrutura de dados mais complexa e famosa do Pandas: o **DataFrame**, que √© basicamente uma cole√ß√£o de Series.

-----

# üìö Conte√∫do Explicado: Mergulhando Fundo

### 1\. Criando a `Series`: O G√™nesis dos Dados

A fun√ß√£o `pd.Series()` √© o seu portal para criar essa estrutura de dados m√°gica. Ela √© bastante flex√≠vel e aceita diversos tipos de dados como entrada. Vamos explorar os principais.

A sintaxe b√°sica √© `pd.Series(data, index, ...)`:

  - `data`: Os valores que voc√™ quer armazenar (uma lista, um array, um dicion√°rio...).
  - `index`: Os r√≥tulos que voc√™ quer dar a esses valores. **Se voc√™ n√£o fornecer um, o Pandas criar√° um √≠ndice num√©rico padr√£o (`0, 1, 2...`)**.
  - `name`: Uma √≥tima pr√°tica √© nomear sua Series, especialmente quando ela for se tornar uma coluna de um DataFrame.

-----

#### a) O Modo Mais Simples: A partir de uma lista

Come√ßamos com o b√°sico. O Pandas, por padr√£o, j√° entende o que fazer.

```python
import pandas as pd
s = pd.Series([10, 20, 30])
print(s)
```

**Sa√≠da Esperada**:

```
0    10
1    20
2    30
dtype: int64
```

**O que aconteceu?**
O Pandas pegou sua lista de valores e, como n√£o especificamos um √≠ndice, ele criou um para n√≥s. Note que ele tamb√©m detectou o tipo de dado (`dtype`) automaticamente. Simples assim\!

-----

#### b) Adicionando R√≥tulos e Nome

Aqui, a m√°gica come√ßa a acontecer. Vamos dar nomes aos nossos dados, tornando-os mais significativos.

```python
s = pd.Series([10, 20, 30], index=['a', 'b', 'c'], name='valores')
print(s)
```

**Sa√≠da**:

```
a    10
b    20
c    30
Name: valores, dtype: int64
```

Agora, cada valor est√° associado a um r√≥tulo personalizado. O nome da Series (`valores`) torna a sua inten√ß√£o ainda mais clara.

-----

#### c) O Atalho Inteligente: Usando um Dicion√°rio

Se seus dados j√° v√™m como um dicion√°rio, o Pandas √© esperto o suficiente para saber que as **chaves** devem se tornar os **√≠ndices**.

```python
s = pd.Series({'jan': 100, 'fev': 150, 'mar': 120})
print(s)
```

**Sa√≠da**:

```
jan    100
fev    150
mar    120
dtype: int64
```

Esse √© um dos recursos mais convenientes do Pandas para iniciar a manipula√ß√£o de dados de forma r√°pida.

-----

#### d) Outras Maneiras de Criar

A Series √© compat√≠vel com outras estruturas de dados muito comuns:

  - **Do NumPy**:

<!-- end list -->

```python
import numpy as np
arr = np.array([1.5, 2.0, 3.7])
s = pd.Series(arr, index=['x', 'y', 'z'])
```

  - **A partir de um valor √∫nico (Scalar)**:

<!-- end list -->

```python
s = pd.Series(5, index=['a', 'b', 'c'])
```

Isso cria uma Series onde todos os valores s√£o `5`, um truque √∫til para inicializar dados.

-----

### 2\. Acessando os Dados: A Arte da Sele√ß√£o

A grande vantagem de ter √≠ndices √© a flexibilidade para acessar seus dados. Voc√™ pode usar tanto a posi√ß√£o quanto o r√≥tulo.

  - **Sele√ß√£o simples**: `s[0]` (posi√ß√£o) ou `s['a']` (r√≥tulo).
  - **Sele√ß√£o expl√≠cita com `.loc` e `.iloc`**: Essa √© a forma mais recomendada, pois evita ambiguidades.
      - `.loc` (de "location") usa **r√≥tulos**. Use `s.loc['a']`.
      - `.iloc` (de "integer location") usa **posi√ß√µes inteiras**. Use `s.iloc[0]`.

-----

### 3\. A Matem√°tica Vetorizada: Efici√™ncia M√°xima

Um dos maiores benef√≠cios do Pandas √© a capacidade de realizar opera√ß√µes matem√°ticas em todos os elementos de uma Series de uma s√≥ vez, sem precisar de loops.

```python
s = pd.Series([10, 20, 30])
s_dobrada = s * 2
# Sa√≠da:
# 0    20
# 1    40
# 2    60
```

Isso √© incrivelmente mais r√°pido e eficiente do que usar um loop `for`.

**A Armadilha do Alinhamento de √çndices**: A intelig√™ncia da Series vai ainda mais longe. Quando voc√™ soma duas Series, o Pandas alinha os dados pelos √≠ndices antes de somar, gerando `NaN` (Not a Number) onde n√£o h√° correspond√™ncia.

```python
s1 = pd.Series([1, 2, 3], index=['a', 'b', 'c'])
s2 = pd.Series([10, 20], index=['a', 'b'])
s1 + s2
```

**Sa√≠da**:

```
a    11.0
b    22.0
c     NaN
dtype: float64
```

Note que o resultado para o √≠ndice `'c'` foi `NaN`. Isso √© um comportamento intencional e muito poderoso, que previne erros de dados desalinhados. O Pandas prefere te avisar com um `NaN` do que somar dados de forma incorreta.

-----

### 4\. M√©todos Utilit√°rios: Seu Kit de Ferramentas de An√°lise

A Series vem com uma s√©rie de m√©todos j√° prontos para a an√°lise. Eles s√£o a sua caixa de ferramentas para rapidamente inspecionar e resumir os dados.

  - `s.head(n)`: Mostra as primeiras `n` linhas (√≥timo para dar uma espiada).
  - `s.tail(n)`: Mostra as √∫ltimas `n` linhas.
  - `s.describe()`: Calcula estat√≠sticas descritivas (m√©dia, desvio padr√£o, m√≠nimo, quartis...).
  - `s.mean()` e `s.sum()`: C√°lculos r√°pidos e diretos.
  - `s.value_counts()`: Contagem de ocorr√™ncias √∫nicas de cada valor.
  - `s.unique()`: Retorna os valores √∫nicos.
  - `s.to_frame()`: Converte sua Series em um DataFrame (o que veremos na pr√≥xima aula\!).
  - `s.to_numpy()`: Transforma sua Series em um array NumPy.

-----

### 5\. Lidando com o Lado Escuro dos Dados: Valores Ausentes

Dados do mundo real raramente s√£o perfeitos. Quase sempre haver√° valores ausentes, que o Pandas representa como `NaN`. Saber lidar com eles √© uma habilidade fundamental.

  - `s.isna()`: Retorna uma Series de `True`/`False` indicando onde os valores est√£o ausentes.
  - `s.dropna()`: Remove as linhas com valores ausentes.
  - `s.fillna(valor)`: Preenche os valores ausentes com um valor que voc√™ escolher (por exemplo, a m√©dia da Series).

-----

# üìà Hora de Praticar: Um Exemplo do Dia a Dia

Vamos unir tudo o que vimos at√© agora em um exemplo pr√°tico. Imagine que voc√™ est√° analisando as vendas de uma semana.

```python
import pandas as pd
import numpy as np

# Vamos criar uma Series de vendas, simulando um dia sem registro (NaN)
vendas = pd.Series([250, 300, np.nan, 410, 380], index=['seg', 'ter', 'qua', 'qui', 'sex'], name='vendas')
print("--- Vendas Brutas ---")
print(vendas)
print("\n--- Descri√ß√£o Estat√≠stica ---")
print(vendas.describe())
```

**O que fizemos?**
Criamos a Series com os dados e √≠ndices rotulados. Usamos `np.nan` (do NumPy) para representar o dia sem registro. Em seguida, usamos `.describe()` para ter uma vis√£o geral dos nossos dados de forma instant√¢nea.

-----

# üß™ Demonstra√ß√£o Aplicada: A An√°lise em 4 Passos

Agora, vamos aplicar um pequeno fluxo de an√°lise de dados, como se estiv√©ssemos em uma situa√ß√£o real.

```python
# 1. Cria√ß√£o: Nossa Series de vendas j√° com um valor ausente
vendas = pd.Series({'seg': 250, 'ter': 300, 'qua': None, 'qui': 410, 'sex': 380}, name='vendas')

# 2. Inspe√ß√£o: Usamos describe para entender a distribui√ß√£o dos dados
print("--- Estat√≠sticas iniciais ---")
print(vendas.describe())

# 3. Tratamento de Dados Ausentes: Preenchemos o dia que faltou com a m√©dia
vendas_tratadas = vendas.fillna(vendas.mean())
print("\n--- Vendas ap√≥s preencher 'qua' com a m√©dia ---")
print(vendas_tratadas)

# 4. C√°lculo de Indicadores: A magia da an√°lise!
total_vendas = vendas_tratadas.sum()
media_vendas = vendas_tratadas.mean()
dia_de_pico = vendas_tratadas.idxmax() # idxmax retorna o √≠ndice do valor m√°ximo
media_movel_3dias = vendas_tratadas.rolling(window=3).mean() # M√©dia m√≥vel de 3 dias

print(f"\nTotal de vendas na semana: {total_vendas}")
print(f"M√©dia di√°ria de vendas: {media_vendas:.2f}")
print(f"Dia com mais vendas: {dia_de_pico}")
print("\n--- M√©dia M√≥vel de 3 Dias ---")
print(media_movel_3dias)
```

**O que aprendemos aqui?**

  - `fillna()` com `mean()` √© uma t√©cnica comum para preencher dados ausentes de forma inteligente.
  - M√©todos como `idxmax()` e `rolling()` s√£o atalhos poderosos para encontrar informa√ß√µes e tend√™ncias rapidamente.

-----

# üìé Dicas Pr√°ticas e Armadilhas Comuns para Evitar

  - **Alinhamento de √çndices**: Sempre se lembre que o Pandas far√° o alinhamento de √≠ndices antes de uma opera√ß√£o. Fique atento aos `NaN`s que isso pode gerar.
  - **Tipos de Dados e `NaN`**: Se a sua Series for de tipo inteiro (`int64`) e voc√™ adicionar um `NaN`, ela ser√° automaticamente convertida para `float64` porque `NaN` n√£o √© um inteiro. Isso √© um comportamento normal, mas √© algo que voc√™ deve estar ciente.
  - **`.loc` vs `.iloc`**: A pr√°tica recomendada √© usar `.loc` para sele√ß√µes por r√≥tulo e `.iloc` para sele√ß√µes por posi√ß√£o. A diferen√ßa √© sutil, mas evita comportamentos inesperados.

-----

# üîÑ Transi√ß√µes e Conex√µes

  - **Vem de**: Sua experi√™ncia com listas e dicion√°rios em Python. A Series √© a pr√≥xima evolu√ß√£o dessas estruturas, otimizada para an√°lise de dados.
  - **Vai para**: A pr√≥xima aula, onde vamos desmistificar o **DataFrame**. Agora que voc√™ entende o que √© uma `Series`, ser√° muito mais f√°cil entender o DataFrame, que √©, essencialmente, uma cole√ß√£o de Series que compartilham um mesmo √≠ndice.

-----

# üé® Recursos Visuais e Mentais (Para Pensar)

1.  **Series vs. DataFrame**: Pense na Series como uma √∫nica coluna, e no DataFrame como uma planilha inteira. O DataFrame √© a uni√£o de v√°rias Series.
2.  **O Fluxo da An√°lise**: Mantenha este fluxo mental para qualquer an√°lise de dados: **Criar** ‚Üí **Inspecionar** ‚Üí **Tratar** (dados ausentes, erros) ‚Üí **Calcular Indicadores** ‚Üí **Visualizar**.
3.  **Diagrama de Alinhamento**: Imagine duas Series, cada uma com seus √≠ndices. Ao som√°-las, o Pandas desenha uma linha imagin√°ria entre os √≠ndices correspondentes e s√≥ ent√£o realiza a soma. Onde n√£o h√° correspond√™ncia, ele escreve `NaN`.

-----

Espero que esta nova abordagem tenha tornado a compreens√£o da **Series** mais clara e envolvente\! Agora que voc√™ domina essa estrutura fundamental, a transi√ß√£o para o DataFrame ser√° muito mais tranquila.

Pronto para o pr√≥ximo passo?

--- 

# üß™ Exerc√≠cios

## üß© Parte 1: Cria√ß√£o e Estrutura

1. **Crie uma Series com os n√∫meros `5`, `10`, `15`, `20`. Exiba-a na tela.**
2. **Crie uma Series com os valores `[100, 200, 300]` e √≠ndices personalizados `['A', 'B', 'C']`. D√™ o nome ‚Äúvalores‚Äù.**
3. **Crie uma Series a partir de um dicion√°rio com os meses `'jan': 120`, `'fev': 150`, `'mar': 130`.**
4. **Crie uma Series com valor escalar `7` e √≠ndices `['x', 'y', 'z']`.**
5. **Crie uma Series a partir de um array NumPy com os valores `[1.1, 2.2, 3.3]` e √≠ndices `['a', 'b', 'c']`.**

---

## üîç Parte 2: Acesso e Sele√ß√£o

6. **Crie uma Series com os valores `[10, 20, 30, 40, 50]`. Exiba o terceiro valor usando `.iloc`.**
7. **Utilize `.loc` para acessar o valor com √≠ndice `'B'` em uma Series com √≠ndices `['A', 'B', 'C']`.**
8. **Exiba os dois √∫ltimos elementos de uma Series usando `.tail()`.**
9. **Utilize fatiamento para exibir os valores entre os √≠ndices `'seg'` e `'qua'` em uma Series de dias da semana.**
10. **Crie uma Series com 5 valores e exiba apenas os valores maiores que `25`.**

---

## üßÆ Parte 3: Opera√ß√µes e Estat√≠sticas

11. **Crie duas Series com √≠ndices parcialmente sobrepostos e some-as. Observe o alinhamento autom√°tico.**
12. **Utilize `.mean()` para calcular a m√©dia de uma Series de notas.**
13. **Utilize `.sum()` para calcular o total de vendas semanais.**
14. **Utilize `.describe()` para obter estat√≠sticas de uma Series de temperaturas.**
15. **Utilize `.value_counts()` para contar quantas vezes cada valor aparece em uma Series.**

---

## üßº Parte 4: Tratamento de Dados Ausentes

16. **Crie uma Series com valores `[10, np.nan, 30, np.nan, 50]`. Use `.isna()` para identificar os ausentes.**
17. **Utilize `.fillna()` para substituir os valores ausentes pela m√©dia da Series.**
18. **Utilize `.dropna()` para remover os valores ausentes.**
19. **Crie uma Series com dados de vendas e calcule a m√©dia m√≥vel com janela de 3 dias usando `.rolling().mean()`.**
20. **Converta uma Series para DataFrame com `.to_frame()` e depois para NumPy array com `.to_numpy()`.**
